-- Custom types
create type public.app_permission as enum ('channels.delete', 'messages.delete');
create type public.app_role as enum ('admin', 'moderator');

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references public.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

create function public.authorize(
  requested_permission app_permission
)
returns boolean as $$
declare
  bind_permissions int;
begin
  select count(*)
  from public.role_permissions
  where role_permissions.permission = authorize.requested_permission
    and (role_permissions.role = (select (auth.jwt() ->> 'user_role')::public.app_role))
  into bind_permissions;

  return bind_permissions > 0;
end;
$$ language plpgsql security definer set search_path = '';

-- You can then use the authorize method within your RLS policies. For example, to enable the desired delete access, you would add the following policies:

--create policy "Allow authorized delete access" on public.channels for delete using ( authorize('channels.delete') );
--create policy "Allow authorized delete access" on public.messages for delete using ( authorize('messages.delete') );
